#version 440 core

struct Object {
    // x = material id
    // y = refered to in other objects
    // z = rendered to screen
    // a = type id
    // NOTE(SpaceCat~Chan): 
    // could be packed further by having material id actually represent mat_id + 1
    // and have 0 mean the object isn't rendered, but padding and alignment rules mean it doesn't matter
    uvec4 mrrt;
    vec4 args1;
    vec4 args2;
};

struct Material {
    // portal translation is packed into the last element of each of the first three vectors
    vec4 color;
    vec4 emitance;
    // x = metalness
    // y = roughness
    // z = is portal?
    // a = see above
    vec4 mrpx;
    vec4 rotate_around;
    // quaternion, x = yz, y = xz, z = xy, w = s 
    vec4 rotation;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 1) readonly buffer objects_buf {
    Object objects[];
};

layout(std430, binding = 2) readonly buffer materials_buf {
    Material materials[];
};

struct Ray {
    // NOTE(SpaceCat~Chan): gonna avoid vec3 like the plague
    // also, i'm using the w component to transfer extra data, because why not
    // specifically, if the direction w is 1, then it was created using the metallic method
    // and then the painter doesn't need to include the distibution_ggx term
    // and if the w is -1, then it's a fake ray and further bounces should not be calculated
    vec4 position;
    vec4 direction;
};

layout(std430, binding = 3) readonly buffer in_rays_buf {
    Ray in_rays[];
};

layout(std430, binding = 4) buffer out_rays_buf {
    Ray out_rays[];
};

struct HitResult {
    vec4 normal;
    // 0 means "no hit", else subtract one to get the actual object id it hit
    uint object;
    // these don't actually matter, array stride is 8 because alignment either way
    uint RESERVED1;
    uint RESERVED2;
    uint RESERVED3;
};

layout(std430, binding = 5) buffer hit_results_buf {
    HitResult hit_results[];
};

layout(std430, binding = 6) readonly buffer rand_wide_buf {
    uint rand_wide[];
};
layout(binding = 7) uniform rand_deep_buf {uint rand_deep;};

// 8 and 9 used for colors

// lets hope no one needs more
const uint MAX_OBJECTS_REFERED_TO = 8;

uint cur_refer_index = 0;
float refer_buffer[MAX_OBJECTS_REFERED_TO];
uint refer_material_buffer[MAX_OBJECTS_REFERED_TO];


// i just want my damn multiple return values
uint material_return;

const uint SPHERE_ID = 0;
float sdf_sphere(Object self, vec3 position) {
    material_return = self.mrrt.x;
    vec3 sphere_position = self.args1.xyz;
    float dist = distance(sphere_position, position);
    return dist - self.args1.a;
}

const uint BOX_ID = 1;
float sdf_box(Object self, vec3 position) {
    material_return = self.mrrt.x;
    vec3 lower_corner = self.args1.xyz;
    vec3 upper_corner = self.args2.xyz;
    vec3 center = (lower_corner + upper_corner) / 2.0;
    vec3 b = center - lower_corner;

    vec3 q = abs(center - position) - b;
    float dist = distance(max(q, vec3(0.0,0.0,0.0)), vec3(0.0,0.0,0.0));
    return dist + min(max(max(q.x,q.y),q.z),0.0);
}

// ummmm, can't really make this... lack of recursion...
const uint POS_MODULO_ID = 2;
float sdf_pos_modulo(Object self, vec3 position) {
    return 1e10;
}

const uint INV_ID = 3;
float sdf_inv(Object self, vec3 position) {
    float sdf = refer_buffer[uint(self.args1.x)];
    material_return = refer_material_buffer[uint(self.args1.x)];
    return -sdf;
}

const uint MAX_ID = 4;
float sdf_max(Object self, vec3 position) {
    float a1 = refer_buffer[uint(self.args1.x)];
    float a2 = refer_buffer[uint(self.args1.y)];
    if (a1 > a2) {
        material_return = refer_material_buffer[uint(self.args1.x)];
        return a1;
    } else {
        material_return = refer_material_buffer[uint(self.args1.y)];
        return a2;
    }
}

const uint MIN_ID = 5;
float sdf_min(Object self, vec3 position) {
    float a1 = refer_buffer[uint(self.args1.x)];
    float a2 = refer_buffer[uint(self.args1.y)];
    if (a1 < a2) {
        material_return = refer_material_buffer[uint(self.args1.x)];
        return a1;
    } else {
        material_return = refer_material_buffer[uint(self.args1.y)];
        return a2;
    }
}

const uint TORUS_ID = 6;
float sdf_torus(Object self, vec3 position) {
    material_return = self.mrrt.x;
    vec3 point = self.args1.xyz - position;
    vec3 move_by = point;
    move_by.y = 0;
    if (move_by == vec3(0.0,0.0,0.0)) {
        move_by = vec3(1.0,0.0,0.0);
    }
    move_by = self.args1.a * normalize(move_by);
    point -= move_by;

    return length(point) - self.args2.x;
}

float sdf_single(Object self, vec3 position) {
    float dist = 0.0;
    switch (uint(self.mrrt.a)) {
        case SPHERE_ID:
            dist = sdf_sphere(self, position);
            break;
        case BOX_ID:
            dist = sdf_box(self, position);
            break;
        case POS_MODULO_ID:
            dist = sdf_pos_modulo(self, position);
            break;
        case INV_ID:
            dist = sdf_inv(self, position);
            break;
        case MAX_ID:
            dist = sdf_max(self, position);
            break;
        case MIN_ID:
            dist = sdf_min(self, position);
            break;
        case TORUS_ID:
            dist = sdf_torus(self, position);
            break;
        default:
            // invalid id, not good
            dist = 1e10;
            break;
    }
    if(self.mrrt.y != 0) {
        refer_buffer[cur_refer_index] = dist;
        refer_material_buffer[cur_refer_index] = material_return;
        cur_refer_index++;
    }
    return dist;
}

// x = distance, y = object index, z = material index
vec3 sdf(vec3 position) {
    cur_refer_index = 0;
    float min_dist = 1e9;
    uint min_index = 0;
    uint min_mat_index;
    for(uint cur=0; cur < objects.length(); cur++) {
        float dist = sdf_single(objects[cur], position);
        if(objects[cur].mrrt.z != 0 && dist < min_dist) {
            min_dist = dist;
            min_index = cur;
            min_mat_index = material_return;
        }
    }
    return vec3(min_dist,float(min_index),float(min_mat_index));
}

const uint MAX_MARCH = 200;
const float DISTANCE_CUTOFF = 1e-3;
const float MAX_DISTANCE = 1000;

vec3 final_march_position = vec3(0.0,0.0,0.0);
vec3 continue_march_from = vec3(0.0,0.0,0.0);

// returns object id + 1 and mat id, 0 means no hit (god i wish i could have sum types and tuples)
uvec2 march(vec3 position, vec3 direction) {
    float total_distance = 0.0;
    for(uint counter=0; counter<MAX_MARCH; counter++) {
        vec3 ret = sdf(position);
        float dist = ret.x;
        total_distance += dist;
        uint hit = uint(ret.y);
        if(total_distance > MAX_DISTANCE) {
            return uvec2(0,0);
        }
        if(dist < DISTANCE_CUTOFF) {
        final_march_position = position;
            return uvec2(hit + 1, uint(ret.z));
        }
        continue_march_from = position;
        position += direction * dist;
    }
    return uvec2(0,0);
}

vec3 find_normal(vec3 position) {
    return normalize(vec3(
        sdf(position + vec3(0.01, 0, 0)).x - sdf(position - vec3(0.01, 0, 0)).x,
        sdf(position + vec3(0, 0.01, 0)).x - sdf(position - vec3(0, 0.01, 0)).x,
        sdf(position + vec3(0, 0, 0.01)).x - sdf(position - vec3(0, 0, 0.01)).x
    ));
}

// fuck you, i made this one myself
vec4 vecs_to_quat(vec3 from, vec3 to) {
    if((from + to) == vec3(0,0,0)) {
        // the "to" vector is always (0,1,0), so this is fine
        return vec4(1.0, 0.0, 0.0, 0.0);
    }
    vec3 halfway = normalize(from + to);

    float scal = from.x * halfway.x + from.y * halfway.y + from.z * halfway.z;
    float xy = from.x * halfway.y - from.y * halfway.x;
    float xz = from.x * halfway.z - from.z * halfway.x;
    float yz = from.y * halfway.z - from.z * halfway.y;
    return vec4(yz, xz, xy, scal);
}

mat4 quat_to_mat4(vec4 quat) {
    float yz = quat.x;
    float xz = quat.y;
    float xy = quat.z;
    float scal = quat.w;

    float x2 = yz + yz;
    float y2 = xz + xz;
    float z2 = xy + xy;

    float xx2 = x2 * yz;
    float xy2 = x2 * xz;
    float xz2 = x2 * xy;

    float yy2 = y2 * xz;
    float yz2 = y2 * xy;
    float zz2 = z2 * xy;

    float sy2 = y2 * scal;
    float sz2 = z2 * scal;
    float sx2 = x2 * scal;

    return mat4(
        1 - yy2 - zz2, xy2 + sz2, xz2 - sy2, 0,
        xy2 - sz2, 1 - xx2 - zz2, yz2 + sx2, 0,
        xz2 + sy2, yz2 - sx2, 1 - xx2 - yy2, 0,
        0,         0,         0,             1
    );
}

uint rng_state;

uint rand_pcg()
{
    uint state = rng_state;
    rng_state = rng_state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

uint pcg_hash(uint in_)
{
    uint state = in_ * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

uint hash_combine(uint a, uint b) {
    return a ^ b + 0x9e3779b9u + (a << 6) + (a >> 2);
}

float get_rand() {
    uint rand = rand_pcg();
    return float(rand) / float(0xffffffffu);
}

float PI = radians(180);

vec3 random_point_on_sphere() {
    float u1 = acos(get_rand() * 2 - 1) - PI / 2;
    float cos_u1 = cos(u1);
    float u2 = get_rand() * 2 * PI;
    float x = sin(u2) * cos_u1;
    float y = cos(u2) * cos_u1;
    float z = sin(u1);
    return vec3(x,y,z);
}


// x is smallest, y is largest
vec2 distribution_ggx_limits(float roughness) {
    float r2 = roughness * roughness * roughness * roughness;

    return vec2(r2, r2 / (r2 * r2));
}

float inverse_distribution_ggx(float roughness, float value) {
    float r2 = roughness * roughness * roughness * roughness;

    float denom = r2 * r2 * value - 2 * value * r2 + value;

    float num1 = value - r2 * value;
    float num2 = sqrt((r2 - 1.0) * (r2 - 1.0) * r2 * value);

    float ans1 = (num1 - num2) / denom;
    float ans2 = (num1 + num2) / denom;

    if (ans1 < 0.0) {
        return ans2;
    } else {
        return ans1;
    }
}

void main() {
    
    uint curr_index = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x;
    
    uint val = pcg_hash(rand_deep);
    rng_state = hash_combine(val, rand_wide[curr_index]);

    Ray ray = in_rays[curr_index];
    if (ray.direction.w == -1) {
        HitResult hit_result_obj = {
            vec4(0,1,0,0),
            uint(0),
            uint(0),uint(0),uint(0)
        };
        hit_results[curr_index] = hit_result_obj;
        Ray error = {
            vec4(-1,-1,-1,-1), vec4(-1,-1,-1,-1)
        };
        out_rays[curr_index] = error;
    }
    uvec2 hit_result = march(ray.position.xyz, ray.direction.xyz);
    vec3 continue_from = continue_march_from;
    if (hit_result.x == 0) {
        HitResult hit_result_obj = {
            vec4(0,1,0,0),
            hit_result.x,
            uint(0),uint(0),uint(0)
        };
        hit_results[curr_index] = hit_result_obj;
        Ray error = {
            vec4(-1,-1,-1,-1), vec4(-1,-1,-1,-1)
        };
        out_rays[curr_index] = error;
    } else {
        uint object = hit_result.x - 1;
        vec3 hit_pos = final_march_position;
        vec3 normal = find_normal(hit_pos);
        HitResult hit_result_obj = {
            vec4(normal,0),
            hit_result.y + 1,
            uint(0),uint(0),uint(0)
        };
        Material mat = materials[hit_result.y];
        hit_results[curr_index] = hit_result_obj;
        if (mat.mrpx.z == 1.0) {
            vec3 translation = vec3(mat.color.w, mat.emitance.w, mat.mrpx.w);
            mat4 rotation = quat_to_mat4(mat.rotation);
            vec3 final_pos = (rotation * vec4(hit_pos - mat.rotate_around.xyz, 0)).xyz + mat.rotate_around.xyz;
            Ray res = {
                vec4(final_pos + translation,0),
                rotation * vec4(ray.direction.xyz, 0)
            };
            out_rays[curr_index] = res;
            return;
        }
        // goal: find out what the out going ray should look like
		mat4 rotation = quat_to_mat4(vecs_to_quat(vec3(0,1,0), normal));
        float metalness_test = get_rand();
        if (mat.mrpx.y == 1 || metalness_test > mat.mrpx.x) {
            // non-metalic method
            // this one is simple, just get a point and move it to the correct hemisphere
            vec3 dir = random_point_on_sphere();
            dir.y = abs(dir.y);
            vec3 final_dir = (rotation * vec4(dir,0)).xyz;
            Ray res = {
                vec4(continue_from,0),
                vec4(final_dir, 0)
            };
            out_rays[curr_index] = res;
            return;
        } else {
            //return;
            // metalic method
            // significantly more complex
            // requires inverting a complex function and detecting some NaNs
            if(mat.mrpx.y == 0) {
                Ray res = {
                    vec4(continue_from, 0),
                    vec4(reflect(ray.direction.xyz, normal),1)
                };
                out_rays[curr_index] = res;
            } else {
                vec2 limits = distribution_ggx_limits(mat.mrpx.y);
                float rand_val = get_rand();
                rand_val *= rand_val;
                rand_val *= limits.y - limits.x;
                rand_val += limits.x;
                float cos_angle = inverse_distribution_ggx(mat.mrpx.y, rand_val);
                float sin_angle = sqrt(1 - cos_angle * cos_angle);
                float theta = get_rand() * 2 * PI;
                vec3 halfway = normalize(vec3(cos(theta) * sin_angle, cos_angle, sin(theta) * sin_angle));
                halfway = (rotation * vec4(halfway,0)).xyz;
                vec3 dir = reflect(ray.direction.xyz, halfway);
                Ray res = {
                    vec4(continue_from, 0),
                    vec4(dir, 1),
                };
                out_rays[curr_index] = res;
            }
        }
    }
}

