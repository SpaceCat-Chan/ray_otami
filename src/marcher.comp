#version 440 core

struct Object {
    // x = material id
    // y = refered to in other objects
    // z = rendered to screen
    // a = type id
    // NOTE(SpaceCat~Chan): 
    // could be packed further by having material id actually represent mat_id + 1
    // and have 0 mean the object isn't rendered, but padding and alignment rules mean it doesn't matter
    uvec4 mrrt;
    vec4 args1;
    vec4 args2;
};
struct Material {
    vec4 color;
    vec4 emitance;
    // x = metalness
    // y = roughness
    // z = unused
    // a = unused
    vec4 mrxx;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 1) readonly buffer objects_buf {
    Object objects[];
};

layout(std430, binding = 2) readonly buffer materials_buf {
    Material materials[];
};

struct Ray {
    // NOTE(SpaceCat~Chan): gonna avoid vec3 like the plague
    // also, i'm using the w component to transfer extra data, because why not
    // specifically, if the direction w is 1, then it was created using the metallic method
    // and then the painter doesn't need to include the distibution_ggx term
    // and if the w is -1, then it's a fake ray and further bounces should not be calculated
    vec4 position;
    vec4 direction;
};

layout(std430, binding = 3) readonly buffer in_rays_buf {
    Ray in_rays[];
};

layout(std430, binding = 4) buffer out_rays_buf {
    Ray out_rays[];
};

struct HitResult {
    vec4 normal;
    // 0 means "no hit", else subtract one to get the actual object id it hit
    uint object;
    // these don't actually matter, array stride is 8 because alignment either way
    uint RESERVED1;
    uint RESERVED2;
    uint RESERVED3;
};

layout(std430, binding = 5) buffer hit_results_buf {
    HitResult hit_results[];
};

layout(std430, binding = 6) readonly buffer rand_wide_buf {
    uint rand_wide[];
};
layout(binding = 7) uniform rand_deep_buf {uint rand_deep;};

// 8 and 9 used for colors

// lets hope no one needs more
const uint MAX_OBJECTS_REFERED_TO = 8;

uint cur_refer_index = 0;
float refer_buffer[MAX_OBJECTS_REFERED_TO];

const uint SPHERE_ID = 0;
float sdf_sphere(Object self, vec3 position) {
    vec3 sphere_position = self.args1.xyz;
    float dist = distance(sphere_position, position);
    return dist - self.args1.a;
}

const uint BOX_ID = 1;
float sdf_box(Object self, vec3 position) {
    vec3 lower_corner = self.args1.xyz;
    vec3 upper_corner = self.args2.xyz;
    vec3 center = (lower_corner + upper_corner) / 2.0;
    vec3 b = center - lower_corner;

    vec3 q = abs(center - position) - b;
    float dist = distance(max(q, vec3(0.0,0.0,0.0)), vec3(0.0,0.0,0.0));
    return dist + min(max(max(q.x,q.y),q.z),0.0);
}

// ummmm, can't really make this... lack of recursion...
const uint POS_MODULO_ID = 2;
float sdf_pos_modulo(Object self, vec3 position) {
    return 1e100;
}

const uint INV_ID = 3;
float sdf_inv(Object self, vec3 position) {
    float sdf = refer_buffer[uint(self.args1.x)];
    return -sdf;
}

const uint MAX_ID = 4;
float sdf_max(Object self, vec3 position) {
    float a1 = refer_buffer[uint(self.args1.x)];
    float a2 = refer_buffer[uint(self.args1.y)];
    return max(a1,a2);
}

const uint MIN_ID = 5;
float sdf_min(Object self, vec3 position) {
    float a1 = refer_buffer[uint(self.args1.x)];
    float a2 = refer_buffer[uint(self.args1.y)];
    return min(a1,a2);
}

const uint TORUS_ID = 6;
float sdf_torus(Object self, vec3 position) {
    vec3 point = self.args1.xyz - position;
    vec3 move_by = point;
    move_by.y = 0;
    if (move_by == vec3(0.0,0.0,0.0)) {
        move_by = vec3(1.0,0.0,0.0);
    }
    move_by = self.args1.a * normalize(move_by);
    point -= move_by;

    return length(point) - self.args2.x;
}

const uint SMOOTH_ID = 7;
float sdf_smooth(Object self, vec3 position)
{
    uint start = uint(self.args1.x);
    uint end = uint(self.args1.y);
    uint step_ = uint(self.args1.z);
    float top_term;
    float bottom_term;
    for (uint cur = start; cur <= end; cur += step_) {
        float val = refer_buffer[cur];
        float val_exp = exp(val * self.args1.a);
        top_term += val * val_exp;
        bottom_term += val_exp;
    }
    return top_term/bottom_term;
}

float sdf_single(Object self, vec3 position) {
    float dist = 0.0;
    switch (uint(self.mrrt.a)) {
        case SPHERE_ID:
            dist = sdf_sphere(self, position);
            break;
        case BOX_ID:
            dist = sdf_box(self, position);
            break;
        case POS_MODULO_ID:
            dist = sdf_pos_modulo(self, position);
            break;
        case INV_ID:
            dist = sdf_inv(self, position);
            break;
        case MAX_ID:
            dist = sdf_max(self, position);
            break;
        case MIN_ID:
            dist = sdf_min(self, position);
            break;
        case TORUS_ID:
            dist = sdf_torus(self, position);
            break;
        case SMOOTH_ID:
            dist = sdf_smooth(self, position);
            break;
        default:
            // invalid id, not good
            dist = 1e100;
            break;
    }
    if(self.mrrt.y != 0) {
        refer_buffer[cur_refer_index] = dist;
        cur_refer_index++;
    }
    return dist;
}

// x = distance, y = object index
vec2 sdf(vec3 position) {
    cur_refer_index = 0;
    float min_dist;
    uint min_index;
    for(uint cur=0; cur < objects.length(); cur++) {
        float dist = sdf_single(objects[cur], position);
        if(objects[cur].mrrt.z != 0 &&dist < min_dist) {
            min_dist = dist;
            min_index = cur;
        }
    }
    return vec2(min_dist,float(min_index));
}

const uint MAX_MARCH = 100;
const float DISTANCE_CUTOFF = 1e-5;
const float MAX_DISTANCE = 1e99;

vec3 final_march_position = vec3(0.0,0.0,0.0);
vec3 continue_march_from = vec3(0.0,0.0,0.0);

// returns object id + 1, 0 means no hit (god i wish i could have sum types and tuples)
uint march(vec3 position, vec3 direction) {
    for(uint counter=0; counter<MAX_MARCH; counter++) {
        vec2 ret = sdf(position);
        float dist = ret.x;
        uint hit = uint(ret.y);
        if(dist > MAX_DISTANCE) {
            return 0;
        }
        if(dist < DISTANCE_CUTOFF) {
        final_march_position = position;
            return hit + 1;
        }
        position += direction * dist;
    }
    continue_march_from = position;
    return 0;
}

vec3 find_normal(vec3 position) {
    return normalize(vec3(
        sdf(position + vec3(0.01, 0, 0)).x - sdf(position - vec3(0.01, 0, 0)).x,
        sdf(position + vec3(0, 0.01, 0)).x - sdf(position - vec3(0, 0.01, 0)).x,
        sdf(position + vec3(0, 0, 0.01)).x - sdf(position - vec3(0, 0, 0.01)).x
    ));
}

// stolen from somewhere, like hell i'm gonna try to figure out how to do that
mat4 rotation3d(vec3 axis, float angle) {
  axis = normalize(axis);
  float s = sin(angle);
  float c = cos(angle);
  float oc = 1.0 - c;

  return mat4(
		oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
		0.0,                                0.0,                                0.0,                                1.0
	);
}

uint rng_state;

uint rand_pcg()
{
    uint state = rng_state;
    rng_state = rng_state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

uint hash_combine(uint a, uint b) {
    return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2);
}

float get_rand() {
    uint rand = rand_pcg();
    return float(rand) / float(0xffffffff);
}

vec3 random_point_on_sphere() {
    // i have a feeling the gpu won't like the 0.01% chance that this loops more than 45 times
    // kinda surprised that glslangValidator isn't shouting about this at all
    // maybe loops of indeterminate length are just ok?
    // wonder if i can make it do tail-call optimisation
    while (true) {
        float x1 = get_rand() * 2 - 1;
        float x2 = get_rand() * 2 - 1;
        float sum = x1 * x1 + x2 * x2;
        if (sum < 1) {
            float factor = 2 * sqrt(1 - sum);
            return vec3(x1 * factor, x2 * factor, 1 - 2 * sum);
        }
    }
}

float PI = radians(180);

// x is smallest, y is largest
vec2 distribution_ggx_limits(float roughness) {
    float r2 = roughness * roughness * roughness * roughness;

    return vec2(r2, r2 / (r2 * r2));
}

float inverse_distribution_ggx(float roughness, float value) {
    float r2 = roughness * roughness * roughness * roughness;

    float denom = r2 * r2 * value - 2 * value * r2 + value;

    float num1 = value - r2 * value;
    float num2 = sqrt((r2 - 1.0) * (r2 - 1.0) * r2 * value);

    float ans1 = (num1 - num2) / denom;
    float ans2 = (num1 + num2) / denom;

    if (ans1 < 0.0) {
        return ans2;
    } else {
        return ans1;
    }
}

void main() {
    uint curr_index = gl_WorkGroupID.x;
    
    rng_state = rand_deep;
    uint val = rand_pcg();
    rng_state = hash_combine(val, rand_wide[curr_index]);

    Ray ray = in_rays[curr_index];
    if (ray.direction.w == -1) {
        Ray error = {
            vec4(-1,-1,-1,-1), vec4(-1,-1,-1,-1)
        };
        out_rays[curr_index] = error;
    }
    uint hit_result = march(ray.position.xyz, ray.direction.xyz);
    if (hit_result == 0) {
        HitResult hit_result_obj = {
            vec4(0,1,0,0),
            hit_result,
            0,0,0
        };
        hit_results[curr_index] = hit_result_obj;
        Ray error = {
            vec4(-1,-1,-1,-1), vec4(-1,-1,-1,-1)
        };
        out_rays[curr_index] = error;
    } else {
        uint object = hit_result - 1;
        vec3 hit_pos = final_march_position;
        vec3 normal = find_normal(hit_pos);
        HitResult hit_result_obj = {
            vec4(normal,0),
            hit_result,
            0,0,0
        };
        hit_results[curr_index] = hit_result_obj;
        // goal: find out what the out going ray should look like
		vec3 axis = cross(normal, vec3(0, 1, 0));
		float angle = -acos(dot(normal, vec3(0, 1, 0)));
		mat4 rotation = rotation3d(axis, angle);
        Material mat = materials[object];
        float metalness_test = get_rand();
        if (mat.mrxx.y == 1 || metalness_test < mat.mrxx.x) {
            // non-metalic method
            // this one is simple, just get a point and move it to the correct hemisphere
            vec3 dir = random_point_on_sphere();
            dir.y = abs(dir.y);
            vec4 final_dir = (rotation * vec4(dir,0));
            Ray res = {
                vec4(continue_march_from,0),
                final_dir
            };
            out_rays[curr_index] = res;
        } else {
            // metalic method
            // significantly more complex
            // requires inverting a complex function and detecting some NaNs
            if(mat.mrxx.y == 0) {
                Ray res = {
                    vec4(continue_march_from, 0),
                    vec4(reflect(ray.direction.xyz, normal),1)
                };
                out_rays[curr_index] = res;
            } else {
                vec2 limits = distribution_ggx_limits(mat.mrxx.y);
                float rand_val = get_rand();
                rand_val *= rand_val;
                rand_val *= limits.y - limits.x;
                rand_val += limits.x;
                float cos_angle = inverse_distribution_ggx(mat.mrxx.y, rand_val);
                float sin_angle = sqrt(1 - cos_angle * cos_angle);
                float theta = get_rand() * 2 * PI;
                vec3 halfway = vec3(cos(theta) * sin_angle, cos_angle, sin(theta) * sin_angle);
                vec3 dir = (-ray.direction.xyz) - dot(halfway, -ray.direction.xyz) * 2 * halfway;
                Ray res = {
                    vec4(continue_march_from, 0),
                    vec4(dir, 1),
                };
                out_rays[curr_index] = res;
            }
        }
    }
}

