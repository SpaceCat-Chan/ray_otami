#version 440 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// copy pasted needed parts from marcher.comp
// they should always have the same interface
// uneeded parts can simply be ommited from where they are uneeded
// in case of a dispute
// marcher.comp is defined as the "correct" interface and painter.comp should be changed

struct Material {
    // portal translation is packed into the last element of each of the first three vectors
    vec4 color;
    vec4 emitance;
    // x = metalness
    // y = roughness
    // z = is portal?
    // a = see above
    vec4 mrpx;
    vec4 rotate_around;
    // quaternion, x = yz, y = xz, z = xy, w = s 
    vec4 rotation;
};

// 1 used for objects

layout(std430, binding = 2) readonly buffer materials_buf {
    Material materials[];
};

struct Ray {
    vec4 position;
    vec4 direction;
};

layout(std430, binding = 3) readonly buffer in_rays_buf {
    Ray in_rays[];
};

layout(std430, binding = 4) buffer out_rays_buf {
    Ray out_rays[];
};

struct HitResult {
    vec4 normal;
    uint object;
    uint RESERVED1;
    uint RESERVED2;
    uint RESERVED3;
};

layout(std430, binding = 5) buffer hit_results_buf {
    HitResult hit_results[];
};

// 6 and 7 used for random data

// NOTE: out always means "further towards the final bounce"
// so painter.comp works in inverse, reading from out and writing to in
layout(std430, binding = 8) buffer in_color_buf {
    vec4 in_color[];
};
layout(std430, binding = 9) readonly buffer out_color_buf {
    vec4 out_color[];
};

float PI = radians(180);

float distribution_ggx(vec3 normal, vec3 halfway, float roughness)
{
    float r2 = roughness * roughness * roughness * roughness;
    float ndot = max(dot(normal, halfway), 0);
    float denom = (ndot * ndot) * (r2 - 1) + 1;

    return r2 / (PI * denom * denom);
}

vec3 fresnel_schlick(float cos_theta, vec3 f0) {
    float cos_magic = clamp(1 - cos_theta, 0, 1);
    return f0 + ((vec3(1) - f0) * cos_magic * cos_magic * cos_magic * cos_magic * cos_magic);
}

float geometry_smith_ggx(float normal_dot_dir, float mapped_roughness) {
    return normal_dot_dir / (normal_dot_dir * (1 - mapped_roughness) + mapped_roughness);
}

float geometry_smith(vec3 normal, vec3 view, vec3 light, float roughness) {
    float r = roughness + 1;
    float k = (r * r) / 8;
    return geometry_smith_ggx(max(dot(normal, view), 0), k) * geometry_smith_ggx(max(dot(normal, light), 0), k);
}

vec4 skybox_color = vec4(0,0,0,1);

void main() {
    uint curr_index = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_LocalInvocationID.x * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
    HitResult hit = hit_results[curr_index];
    if(hit.object == 0) {
        in_color[curr_index] = skybox_color;
        return;
    }
    Material mat = materials[hit.object - 1];

    Ray in_going = in_rays[curr_index];
    Ray out_going = out_rays[curr_index];

    //in_color[curr_index] = 
    //vec4(mat.color.rgb,1);
    //vec4((out_going.direction.xyz + 1) / 2, 1);
    //vec4(put_rays[curr_index].direction.xyz, 1);
    //return;

    if(mat.mrpx.z == 1.0) {
        vec3 color = out_color[curr_index].xyz;
        color *= mat.color.xyz;
        color += mat.emitance.xyz;
        in_color[curr_index] = vec4(color, 1);
        return;
    }

    vec3 halfway = normalize((-in_going.direction.xyz) + out_going.direction.xyz);

    float ndf;
    if(out_going.direction.w == 1) {
        ndf = 1;
    } else {
        ndf = distribution_ggx(hit.normal.xyz, halfway, mat.mrpx.y);
    }
    vec3 f0 = vec3(0.04, 0.04, 0.04);
    f0 = mix(f0, mat.color.xyz, mat.mrpx.x);
    vec3 f = fresnel_schlick(max(dot(hit.normal.xyz, halfway), 0.0), f0);
    float g = geometry_smith(hit.normal.xyz, -in_going.direction.xyz, out_going.direction.xyz, mat.mrpx.y);
    vec3 specular = (g * f * ndf)
        / (4.0 * max(dot(hit.normal.xyz,-in_going.direction.xyz), 0.0) * max(dot(hit.normal.xyz, out_going.direction.xyz),0.0) + 0.000001);
    vec3 k_d = vec3(1) - f;
    k_d *= (1 - mat.mrpx.x);
    vec3 final_color = ((k_d * mat.color.xyz / PI) + specular)
        * out_color[curr_index].xyz
        * max(dot(hit.normal.xyz, out_going.direction.xyz), 0)
        + mat.emitance.xyz;
    in_color[curr_index] = vec4(final_color, 1);
}
